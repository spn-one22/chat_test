# ===============================
# GitLab CI/CD
# Автоматический запуск пайплайна:
# - Запускается ТОЛЬКО если менялся код или конфиги.
# - Если менялись ТОЛЬКО файлы документации (.md, docs/**) — пайплайн НЕ создаётся.
# ===============================

stages: [test, build] # Определяем порядок стадий: сначала тесты, потом сборка контейнеров

# -------------------------------
# Workflow — когда СОЗДАВАТЬ пайплайн в принципе
# -------------------------------
workflow:
  rules:
    # --- 1) Если были изменения в ключевых файлах — запускаем пайплайн ---
    - changes:
        - ".gitlab-ci.yml"      # если поменяли сам pipeline-файл
        - "docker-compose.yml"  # если изменился docker-compose
        - "Dockerfile"          # если изменился Dockerfile
        - "app/**/*"            # если изменился код приложения
        - "grafana/**/*"        # если изменились конфиги Grafana
        - "telegraf/**/*"       # если изменились конфиги Telegraf

    # --- 2) Если изменились ТОЛЬКО файлы документации — НЕ запускаем пайплайн ---
    - changes:
        - "**/*.md"              # все Markdown файлы
        - "docs/**/*"            # папка с документацией
      when: never                 # явно запрещаем запуск

    # --- 3) Всё остальное — тоже НЕ запускать ---
    - when: never

# ============================================
# JOB 1: TEST
# Проверяет Node.js часть приложения (установка зависимостей, сборка)
# ============================================
test:
  stage: test            # Привязка job к стадии "test"
  image: node:20          # GitLab скачает официальный образ Node.js версии 20

  # --- Кэшируем папку с модулями npm, чтобы ускорить повторные сборки ---
  cache:
    key: npm-${CI_COMMIT_REF_SLUG} # уникальный кэш для каждой ветки
    paths:
      - .npm/                      # путь для хранения кэша
    policy: pull-push               # сначала подтягиваем, потом обновляем

  # --- Переменные окружения ---
  variables:
    npm_config_cache: .npm          # npm будет использовать эту папку как кэш

  # --- Команды, которые выполняет GitLab внутри контейнера ---
  script:
    - node -v && npm -v             # выводим версии Node и npm (удобно для логов)
    - npm ci || npm install         # чистая установка зависимостей, если нет — обычная установка
    - npm run build || echo "build optional" # сборка проекта, если команда build есть в package.json

  # --- Когда именно запускать этот job ---
  rules:
    - changes:
        - "app/**/*"                # если изменились файлы приложения
        - "package.json"            # или package.json
        - "package-lock.json"       # или lock-файл зависимостей
        - ".gitlab-ci.yml"          # или сам pipeline-файл

# ============================================
# JOB 2: DOCKER-BUILD
# Собирает Docker-образы всех сервисов по docker-compose.yml
# ============================================
docker-build:
  stage: build                       # Привязка job к стадии "build"
  image: docker:24.0                  # Используем Docker 24.0 для сборки образов

  # --- Docker-in-Docker сервис ---
  services:
    - name: docker:24.0-dind          # Поднимаем внутренний Docker-демон
      command: ["--mtu=1460"]         # Настраиваем MTU для стабильности сети в облаке GitLab

  # --- Переменные для корректной работы Docker внутри GitLab Runner ---
  variables:
    DOCKER_HOST: tcp://docker:2375    # указываем, что будем подключаться к внутреннему docker:dind
    DOCKER_TLS_CERTDIR: ""            # отключаем TLS для простоты
    DOCKER_DRIVER: overlay2           # драйвер хранилища для Docker

  # --- Команды сборки Docker контейнеров ---
  script:
    - docker version                   # проверяем, что Docker работает
    - docker compose version || apk add --no-cache docker-cli-compose # если нет docker compose, ставим его
    - docker compose pull || true      # пробуем подтянуть готовые образы, если они есть
    - docker compose build --pull      # собираем новые образы по docker-compose.yml

  # --- Когда запускать этот job ---
  rules:
    - changes:
        - "docker-compose.yml"         # если изменился docker-compose
        - "Dockerfile"                  # если изменился Dockerfile
        - "app/**/*"                    # если изменился код приложения
        - "grafana/**/*"                # если изменились файлы Grafana
        - "telegraf/**/*"               # если изменились файлы Telegraf

# ============================================
# Пояснения
# ============================================
# 1. Workflow проверяет, стоит ли запускать пайплайн вообще.
#    - Если в коммите ТОЛЬКО файлы документации (.md, docs/) — pipeline даже не создаётся.
#
# 2. Каждый job внутри проверяет уже свои файлы.
#    - Например, job "test" не запустится, если не менялся код Node.js.
#    - job "docker-build" не запустится, если не менялся compose или Dockerfile.
#
# 3. Такой подход экономит ресурсы и делает логику запуска прозрачной:
#    - нет смысла тратить время на сборку контейнеров, если ничего не поменялось в конфиге.
